<!DOCTYPE html>
<html lang="en">
<head>
  <!-- =========================================================
  ===============  SECTION 0 — HEAD & STYLES  =================
  ========================================================== -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Potree Viewer</title>

  <!-- Potree & vendor CSS (LOCAL + RELATIVE PATHS) -->
  <link rel="stylesheet" href="/libs/potree/potree.css" />
  <link rel="stylesheet" href="/libs/jquery-ui/jquery-ui.min.css" />
  <link rel="stylesheet" href="/libs/openlayers3/ol.css" />
  <link rel="stylesheet" href="/libs/spectrum/spectrum.css" />
  <link rel="stylesheet" href="/libs/jstree/themes/mixed/style.css" />

  <style>
    /* ================= Theme: charcoal canvas + neutral sidebar ================= */
    :root{
      --bg-0:#2d2d2f;        /* canvas */
      --panel-0:#272727;     /* sidebar body */
      --panel-1:#272727;     /* sidebar headers */
      --panel-2:#bc6813;     /* active header */
      --btn-0:#272727;       /* buttons idle */
      --btn-1:#2faa47ff;     /* buttons active */
      --border-0:#2faa47ff;  /* accent border */
      --text-0:#e8eaf0;
      --text-dim:#aeb6c0;
    }

    /* Canvas */
    #potree_render_area{ background:var(--bg-0); }

    /* Sidebar shell + neutral divider to scene */
    #potree_sidebar_container{
      background:var(--panel-0);
      color:var(--text-0);
      border-right:1px solid #1b1b1b;
    }
    #potree_render_area{ border-left:1px solid #1b1b1b; }

    /* Remove default blue/teal gradients & shadows */
    #potree_sidebar_container .ui-widget-header,
    #potree_sidebar_container .ui-widget-content{
      background:var(--panel-0) !important;
      background-image:none !important;
      box-shadow:none !important;
      text-shadow:none !important;
      border-color:var(--border-0) !important;
      color:var(--text-0) !important;
    }

    /* Accordion headers (idle & active) */
    #potree_sidebar_container .ui-accordion-header,
    #potree_sidebar_container .ui-accordion .ui-accordion-header,
    #potree_sidebar_container .ui-state-default.ui-accordion-header{
      background:var(--panel-1) !important;
      background-image:none !important;
      color:var(--text-0) !important;
      border:1px solid var(--border-0) !important;
      box-shadow:none !important;
      text-shadow:none !important;
    }
    #potree_sidebar_container .ui-accordion-header.ui-state-active,
    #potree_sidebar_container .ui-widget-header.ui-state-active{
      background:var(--panel-2) !important; /* orange active header */
      background-image:none !important;
      color:#101010 !important;
      border-color:var(--border-0) !important;
    }
    #potree_sidebar_container .ui-accordion-content{
      background:var(--panel-0) !important;
      color:var(--text-0) !important;
      border-color:var(--border-0) !important;
    }

    /* Buttons */
    #potree_sidebar_container .ui-button,
    #potree_sidebar_container .ui-state-default,
    #potree_sidebar_container .ui-widget-header .ui-state-default{
      background:var(--btn-0) !important;
      color:var(--text-0) !important;
      border:1px solid var(--border-0) !important;
      background-image:none !important;
      box-shadow:none !important;
      text-shadow:none !important;
    }
    #potree_sidebar_container .ui-button.ui-state-active,
    #potree_sidebar_container .ui-state-active,
    #potree_sidebar_container .ui-buttonset .ui-state-active{
      background:var(--btn-1) !important;
      color:#0b0b0b !important;
      border-color:var(--border-0) !important;
    }
    #potree_sidebar_container .ui-button:hover,
    #potree_sidebar_container .ui-state-hover{
      filter:brightness(1.06);
    }

    /* Inputs */
    #potree_sidebar_container input,
    #potree_sidebar_container select,
    #potree_sidebar_container textarea{
      background:#1f1f20 !important;
      color:var(--text-0) !important;
      border:1px solid var(--border-0) !important;
    }

    /* Sliders */
    #potree_sidebar_container .ui-slider{
      background:#1f1f20 !important;
      border:1px solid var(--border-0) !important;
      background-image:none !important;
    }
    #potree_sidebar_container .ui-slider .ui-slider-range{
      background:var(--btn-1) !important;
      background-image:none !important;
    }
    #potree_sidebar_container .ui-slider .ui-slider-handle{
      background:#202020 !important;
      border:1px solid var(--border-0) !important;
    }

    /* Tabs */
    #potree_sidebar_container .ui-tabs .ui-tabs-nav{
      background:var(--panel-1) !important;
      border-color:var(--border-0) !important;
      background-image:none !important;
    }
    #potree_sidebar_container .ui-tabs .ui-tabs-nav li a{ color:var(--text-0) !important; }
    #potree_sidebar_container .ui-tabs .ui-tabs-nav li.ui-tabs-active a{ color:#0b0b0b !important; }

    /* Brand header */
    #brandHeader{
      padding:10px 12px;
      background:var(--panel-1);
      border-bottom:1px solid var(--border-0);
    }
    #brandHeader img{ display:block; width:100%; max-height:56px; object-fit:contain; }

    /* Toast */
    #hudToast{
      position:absolute; left:12px; right:12px; bottom:10px; margin:0 auto;
      width:fit-content; max-width:90%;
      background:rgba(39,39,39,.92); color:var(--text-0);
      border:1px solid var(--border-0); border-radius:8px;
      padding:6px 10px; font:12px/1.3 system-ui,Segoe UI,Roboto,Arial,sans-serif;
      pointer-events:none; opacity:0; transition:opacity .15s ease;
      box-shadow:0 6px 20px rgba(0,0,0,.35);
    }
    #hudToast.show{ opacity:1; }

    /* Hotkeys card */
    .hk-card{
      margin:8px 0; border:1px solid var(--border-0);
      border-radius:6px; padding:8px; background:#222; color:var(--text-0);
    }
    .hk-title{ font-weight:700; margin-bottom:6px; }
    .hk-table{ width:100%; font-size:12px; border-collapse:collapse; }
    .hk-table td{ padding:2px 0; vertical-align:top; color:var(--text-0); }
    .hk-table td:first-child{ white-space:nowrap; width:1%; font-weight:600; padding-right:8px; }

    /* Cursor when N-mode */
    body.n-mode{ cursor:crosshair; }

    /* Sidebar scrollbar */
    #potree_sidebar_container,
    #potree_sidebar_container *{
      scrollbar-width:thin;
      scrollbar-color:var(--btn-1) var(--panel-0);
    }
    #potree_sidebar_container::-webkit-scrollbar{ width:10px; }
    #potree_sidebar_container::-webkit-scrollbar-track{ background:var(--panel-0) !important; }
    #potree_sidebar_container::-webkit-scrollbar-thumb{
      background:var(--btn-1) !important;
      border:2px solid var(--panel-0) !important;
      border-radius:8px;
    }
    #potree_sidebar_container::-webkit-scrollbar-thumb:hover{ background:#1fd124 !important; }
    #sidebar_root{ background:var(--panel-0) !important; }

    /* Hide the "Tools" header bar (you asked for this) */
    #menu_tools { display:none !important; }
    #menu_tools + .ui-accordion-content {
      border-top: 0 !important;
      margin-top: 0 !important;
      padding-top: 6px !important;
    }
  </style>
</head>

<body>
  <!-- =========================================================
  ============  SECTION 1 — CONTAINER & LIB SCRIPTS  ==========
  ========================================================== -->
  <div class="potree_container" style="position:absolute; inset:0;">
    <div id="potree_render_area"></div>
    <div id="potree_sidebar_container"></div>
    <div id="hudToast" aria-live="polite"></div>
  </div>

  <!-- ================= Vendor & Potree libs (absolute paths, single load) ================= -->
<script src="/libs/jquery/jquery-3.1.1.min.js"></script>
<script src="/libs/spectrum/spectrum.js"></script>
<script src="/libs/jquery-ui/jquery-ui.min.js"></script>

<!-- THREE (must be before lines.js & potree.js) -->
<script src="/libs/three.js/build/three.min.js"></script>
<script src="/libs/three.js/extra/lines.js"></script>

<!-- remaining vendors -->
<script src="/libs/other/BinaryHeap.js"></script>
<script src="/libs/tween/tween.min.js"></script>
<script src="/libs/d3/d3.js"></script>
<script src="/libs/proj4/proj4.js"></script>
<script src="/libs/openlayers3/ol.js"></script>
<script src="/libs/i18next/i18next.js"></script>
<script src="/libs/jstree/jstree.js"></script>

<!-- Potree + LAS loader -->
<script src="/libs/potree/potree.js"></script>
<script src="/libs/plasio/js/laslaz.js"></script>
  <script>
  // ===========================================================
  // ===============  SECTION 2 — CLEAN START  =================
  // ===========================================================
  try { localStorage.clear(); sessionStorage.clear(); } catch (e) {}

  // ===========================================================
  // ==========  SECTION 3 — VIEWER: INIT & DEFAULTS  ==========
  // ===========================================================
  window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
  document.title = "Potree Viewer";
  viewer.setBackground("grey");
  try { viewer.renderer.setClearColor(0x0E1116, 1); } catch(e){}  // charcoal

  // --- Stable defaults for picking on first load ---
  try {
    viewer.pickWindowSize = 28;
    if (viewer.inputHandler) viewer.inputHandler.pickWindowSize = 28;
    if (viewer.renderer?.setPixelRatio) viewer.renderer.setPixelRatio(window.devicePixelRatio || 1);
  } catch(e){}

  function stabilizePicking(){
    try { viewer.renderer?.setPixelRatio?.(window.devicePixelRatio || 1); } catch(e){}
    try { viewer.onWindowResize && viewer.onWindowResize(); } catch(e){}
    try { viewer.inputHandler?.setScene?.(viewer.scene); } catch(e){}
    viewer.repaint && viewer.repaint();
  }
  requestAnimationFrame(()=>requestAnimationFrame(stabilizePicking));
  window.addEventListener("resize", ()=>requestAnimationFrame(stabilizePicking), {passive:true});

  viewer.setEDLEnabled(false);
  viewer.setFOV(60);
  viewer.setPointBudget(8_000_000);

  // 3-decimal metre formatting everywhere (including canvas labels)
  try {
    viewer.lengthUnit = "m";
    viewer.lengthDecimals = 3;
    viewer.setLengthUnit && viewer.setLengthUnit("m");
    viewer.setLengthDecimals && viewer.setLengthDecimals(3);
  } catch(e){}
  (function(){
    const fmt = (m)=> (Number(m)).toFixed(3) + " m";
    try {
      Potree?.Utils && (Potree.Utils.formatLength = fmt, Potree.Utils.toStringLength = fmt);
      Potree?.utils && (Potree.utils.formatLength = fmt, Potree.utils.toStringLength = fmt);
    } catch(e){}
  })();
  // ===========================================================
  // =====  SECTION 3.6 — PICK WINDOW HARD-LOCK (no races)  ====
  // ===========================================================
  (function lockPickWindow(minPx = 32){
    if (!window.viewer) return;

    function clamp(v){
      v = Number(v);
      return (isFinite(v) && v >= minPx) ? v : minPx;
    }

    try{
      let _v = clamp(viewer.pickWindowSize);
      Object.defineProperty(viewer, 'pickWindowSize', {
        get(){ return _v; },
        set(val){ _v = clamp(val); },
        configurable: true
      });
      viewer.pickWindowSize = minPx;
    }catch(_){}

    try{
      if (viewer.inputHandler){
        let _vh = clamp(viewer.inputHandler.pickWindowSize);
        Object.defineProperty(viewer.inputHandler, 'pickWindowSize', {
          get(){ return _vh; },
          set(val){ _vh = clamp(val); },
          configurable: true
        });
        viewer.inputHandler.pickWindowSize = minPx;
      }
    }catch(_){}

    requestAnimationFrame(()=>requestAnimationFrame(()=>{
      try { viewer.renderer?.setPixelRatio?.(window.devicePixelRatio || 1); } catch(_){}
      try { viewer.onWindowResize && viewer.onWindowResize(); } catch(_){}
      try { viewer.inputHandler?.setScene?.(viewer.scene); } catch(_){}
      viewer.repaint && viewer.repaint();
    }));
  })();

  // ===========================================================
  // ==========  SECTION 4 — GUI: SIDEBAR & HOTKEYS  ===========
  // ===========================================================
  viewer.loadGUI(function(){
    viewer.setLanguage("en");
    viewer.toggleSidebar();

    const $side = $("#potree_sidebar_container");

    // ---- Logo ---------------------------------------------------------------
    (function brandHeader(){
      const logoURL = "/EnableLogo.png?v=" + Date.now();
      const html = `
        <div id="brandHeader">
          <img src="${logoURL}" alt="Logo">
          <div id="brandTitle"
               style="margin-top:8px; font-size:18px; font-weight:700; text-align:center; color:var(--text-0);">
            Point Cloud Viewer
          </div>
        </div>`;
      const $hdrAnchor = $side.find("a[href*='potree.org'], a[href*='github'], a[href*='twitter']").first();
      const $hdrRow = $hdrAnchor.length ? $hdrAnchor.closest("div") : null;
      if ($hdrRow && $hdrRow.length) { $hdrRow.html(html); } else { $side.prepend(html); }
    })();

    // ---- Only use Tools & Navigation (harvest from them) --------------------
    const hide = sel => { const $m=$(sel); if($m.length){$m.hide();$m.next().hide();} };
    const show = sel => { const $m=$(sel); if($m.length){$m.show();$m.next().show();} };
    show("#menu_tools"); show("#menu_navigation");
    hide("#menu_scene"); hide("#menu_appearance"); hide("#menu_edl"); hide("#menu_background");
    hide("#menu_filters"); hide("#menu_about"); hide("#menu_other");

    // ---- Hotkeys card -------------------------------------------------------
    (function injectHotkeysPanel(){
      const $dst = $("#menu_tools").next();
      if(!$dst.length || $("#hotkeysHelp").length) return;
      const html = `
        <section id="hotkeysHelp" class="hk-card">
          <div class="hk-title">Hotkeys</div>
          <table class="hk-table">
            <tr><td>H</td><td>Horizontal chain (Top-Ortho, Z-clamp)</td></tr>
            <tr><td>V</td><td>Vertical chain (pure ΔZ)</td></tr>
            <tr><td>M</td><td>Measure 3D</td></tr>
            <tr><td>O</td><td>Orthographic projection</td></tr>
            <tr><td>P</td><td>Perspective projection</td></tr>
            <tr><td>B</td><td>Clip box show / hide</td></tr>
            <tr><td>C</td><td>Clear all measurements</td></tr>
          </table>
        </section>`;
      $dst.prepend(html);
    })();

    // ---- Open both accordions so their DOM exists ---------------------------
    setTimeout(function(){
      const openAcc = (hdrSel) => {
        const $h=$(hdrSel), $c=$h.next();
        if(!$h.length||!$c.length) return;
        $h.removeClass("ui-accordion-header-collapsed")
          .addClass("ui-accordion-header-active")
          .attr("aria-expanded","true");
        $c.addClass("ui-accordion-content-active")
          .attr("aria-hidden","false")
          .show();
      };
      openAcc("#menu_tools");
      openAcc("#menu_navigation");
    }, 0);

    // ---- Build minimal panel: Hotkeys + 6 views + tips ----------------------
    function buildMinimal(){
      const $toolsBody = $("#menu_tools").next();
      const $navBody   = $("#menu_navigation").next();
      if (!$toolsBody.length) return;

      const $anchor   = $("#hotkeysHelp").length ? $("#hotkeysHelp") : $toolsBody.children().first();
      const $navTitle = $('<div id="enableNavTitle" style="margin:10px 0 6px; text-align:center; font-weight:700; opacity:.85;">Navigation</div>');
      const $viewsRow = $('<div id="enableViews" style="margin:6px 0;"></div>');
      const $tips     = $(`
        <div id="enableNavTips"
             style="margin:6px 0 2px; padding:6px 8px;
                    background:#222; color:var(--text-0);
                    font:12px/1.35 system-ui,Segoe UI,Roboto,Arial,sans-serif; opacity:.95;">
          <div style="margin:2px 0;">Left mouse button: rotate model</div>
          <div style="margin:2px 0;">Middle mouse (drag): pan • Mouse wheel: zoom</div>
          <div style="margin:2px 0;">Refresh browser to clear dimensions</div>
        </div>
      `);
      $anchor.after($navTitle, $viewsRow, $tips);

      // Search pool = Tools + Navigation bodies
      const $pool = $().add($toolsBody).add($navBody);

      function clickable($el){
        const $wrap = $el.closest("a,button");
        return $wrap.length ? $wrap : $el;
      }
      function findViewBtn(name){
        const n = name.toLowerCase();
        let $el = $pool.find('[title], [aria-label], img[alt]').filter(function(){
          const t   = (this.getAttribute('title')||'').toLowerCase();
          const ar  = (this.getAttribute('aria-label')||'').toLowerCase();
          const alt = (this.getAttribute('alt')||'').toLowerCase();
          return t.includes(n) || ar.includes(n) || alt.includes(n);
        }).first();
        if ($el.length) return clickable($el);
        $el = $pool.find('img[src]').filter(function(){
          return (this.getAttribute('src')||'').toLowerCase().includes(n);
        }).first();
        if ($el.length) return clickable($el);
        return $();
      }
      function moveIfFound($el, $dest){ if($el && $el.length){ $el.detach().appendTo($dest); return true; } return false; }

      // 6 view buttons
      ["front","back","left","right","top","bottom"].forEach(n => {
        moveIfFound(findViewBtn(n), $viewsRow);
      });

      // Remove Perspective / Orthographic buttons (you kept hotkeys)
      (function removeCamButtons(){
        const $poolEls = $pool.find("button, .ui-button, a, span, div, img");
        const toHide = [];
        $poolEls.each(function(){
          const $el   = $(this);
          const text  = ($el.text() || "").toLowerCase();
          const title = ($el.attr("title") || "").toLowerCase();
          const aria  = ($el.attr("aria-label") || "").toLowerCase();
          const alt   = ($el.attr("alt") || "").toLowerCase();
          const src   = ($el.attr("src") || "").toLowerCase();
          const isCam =
            text.includes("perspective") || text.includes("orthographic") || text === "ortho" ||
            title.includes("perspective") || title.includes("orthographic") || title === "ortho" ||
            aria.includes("perspective") || aria.includes("orthographic") || aria === "ortho" ||
            alt.includes("perspective") || alt.includes("orthographic") || alt === "ortho" ||
            /persp|ortho/.test(src);
          if (isCam){
            const $btn = $el.closest("button, .ui-button, a").length ? $el.closest("button, .ui-button, a") : $el;
            toHide.push($btn[0]);
          }
        });
        $(toHide).hide();
      })();

      // Hide everything else in Tools
      const keep = new Set([ $("#hotkeysHelp")[0], $navTitle[0], $viewsRow[0], $tips[0] ].filter(Boolean));
      $toolsBody.children().each(function(){
        if (!keep.has(this) && !$(this).find("#hotkeysHelp, #enableViews, #enableNavTips").length){
          $(this).hide();
        }
      });

      // Hide Navigation accordion (we harvested icons)
      $("#menu_navigation").hide();
      $("#menu_navigation").next().hide();
    }

    setTimeout(buildMinimal, 0);
  });

  // ===========================================================
  // ===============  SECTION 5 — HUD TOAST ====================
  // ===========================================================
  function toast(msg){
    const el = document.getElementById("hudToast");
    el.textContent = msg;
    el.classList.add("show");
    clearTimeout(el.__t);
    el.__t = setTimeout(function(){ el.classList.remove("show"); }, 1400);
  }

  // ===========================================================
  // =======  SECTION 6 — GLOBAL HELPERS & STATE VARS  =========
  // ===========================================================
  function synthRightClick(){
    const el = viewer.inputHandler?.domElement || viewer.renderer?.domElement || document.getElementById("potree_render_area");
    if(!el) return;
    ['pointerdown','mousedown','mouseup','pointerup','contextmenu'].forEach(t=>{
      try { el.dispatchEvent(new MouseEvent(t, {button:2, bubbles:true, cancelable:true})); } catch(e){}
    });
  }

  // Detach/restore the clip box so it doesn’t steal clicks
  let __savedClip = null;
  function detachClipBoxForTool(){
    const box = window.__clipBox;
    if (!box) return;
    try{
      __savedClip = {
        vis: box.visible,
        clip: box.clip === true,
        pos: box.position.clone(),
        rot: box.rotation ? box.rotation.clone() : null,
        scale: box.scale.clone(),
        method: (viewer.getClipMethod ? viewer.getClipMethod() : Potree.ClipMethod.INSIDE_ANY),
        task:   (viewer.getClipTask   ? viewer.getClipTask()   : Potree.ClipTask.SHOW_INSIDE)
      };
    }catch(e){}
    try{
      if (viewer.scene.removeVolume) viewer.scene.removeVolume(box);
      else {
        const arr = viewer.scene.volumes || [];
        const i = arr.indexOf(box); if(i>=0) arr.splice(i,1);
      }
    }catch(e){}
    window.__clipBox = null;
    try{ viewer.setClipTask(Potree.ClipTask.NONE); }catch(e){}
    viewer.repaint();
  }
  function restoreClipBoxAfterTool(){
    const saved = __savedClip; __savedClip = null;
    if (!saved) return;
    try{
      const box = new Potree.BoxVolume();
      box.clip = saved.clip;
      box.visible = saved.vis;
      if (saved.rot) box.rotation.copy(saved.rot);
      box.position.copy(saved.pos);
      box.scale.copy(saved.scale);
      viewer.scene.addVolume(box);
      window.__clipBox = box;
      viewer.setClipMethod && viewer.setClipMethod(saved.method);
      viewer.setClipTask   && viewer.setClipTask(saved.task);
      viewer.repaint();
    }catch(e){}
  }

  // Robust picker
  function pickPointFromClientXY(clientX, clientY){
    const canvas = viewer?.renderer?.domElement || document.getElementById("potree_render_area");
    if (!canvas) return null;

    const rect = canvas.getBoundingClientRect();
    const fbW  = (canvas.width  && canvas.width  > 0) ? canvas.width  : Math.round(rect.width  * (window.devicePixelRatio || 1));
    const fbH  = (canvas.height && canvas.height > 0) ? canvas.height : Math.round(rect.height * (window.devicePixelRatio || 1));

    const px = (clientX - rect.left) * (fbW / rect.width);
    const py = (clientY - rect.top)  * (fbH / rect.height);

    const cam = viewer.scene.getActiveCamera();
    const pcs = viewer.scene.pointclouds;

    try{
      if (typeof viewer.pick === "function"){
        const nx =  (px / fbW) * 2 - 1;
        const ny = -(py / fbH) * 2 + 1;
        const res = viewer.pick(cam, {x:nx, y:ny}, {
          pickWindowSize: (typeof viewer.pickWindowSize==='number' ? viewer.pickWindowSize : 24),
          pointclouds: pcs
        });
        if (res && res.position) return res.position.clone();
      }
    }catch(_){}

    try{
      if (Potree?.Utils?.getMousePointCloudIntersection){
        const hitA = Potree.Utils.getMousePointCloudIntersection({x:px, y:py},         cam, viewer.renderer, pcs);
        const hitB = Potree.Utils.getMousePointCloudIntersection({x:px, y:(fbH - py)}, cam, viewer.renderer, pcs);
        const h = hitA || hitB;
        const p = h && (h.position || h.location);
        if (p){ return p.clone ? p.clone() : new THREE.Vector3().copy(p); }
      }
    }catch(_){}

    return null;
  }

  function resyncPickBufferOnce(){
    viewer.onWindowResize && viewer.onWindowResize();
    try{ viewer.inputHandler?.setScene?.(viewer.scene); }catch(e){}
    viewer.repaint && viewer.repaint();
  }
  function resyncPickBuffer(){ requestAnimationFrame(resyncPickBufferOnce); }

  const __pickBump = { active:false, prevBudget:null, prevSizes:new Map() };
  function bumpPickResources(on){
    try{
      if(on){
        if(__pickBump.active) return;
        __pickBump.active = true;
        __pickBump.prevBudget = (viewer.getPointBudget ? viewer.getPointBudget() : viewer.pointBudget);
        const newBudget = Math.max(__pickBump.prevBudget || 8000000, 24000000);
        viewer.setPointBudget ? viewer.setPointBudget(newBudget) : (viewer.pointBudget = newBudget);
        const pcs = viewer.scene?.pointclouds || [];
        __pickBump.prevSizes.clear();
        for (let i=0;i<pcs.length;i++){
          const mat = pcs[i]?.material;
          if (mat){ __pickBump.prevSizes.set(pcs[i].uuid, mat.size); mat.size = Math.max(mat.size || 1.0, 2.5); }
        }
        requestAnimationFrame(()=>viewer.repaint && viewer.repaint());
      } else {
        if(!__pickBump.active) return;
        if(__pickBump.prevBudget != null){
          viewer.setPointBudget ? viewer.setPointBudget(__pickBump.prevBudget) : (viewer.pointBudget = __pickBump.prevBudget);
        }
        const pcs = viewer.scene?.pointclouds || [];
        for (let i=0;i<pcs.length;i++){
          const mat = pcs[i]?.material;
          const prev = __pickBump.prevSizes.get(pcs[i].uuid);
          if (mat != null && prev != null) mat.size = prev;
        }
        __pickBump.prevSizes.clear();
        __pickBump.active = false;
        viewer.repaint && viewer.repaint();
      }
    }catch(e){ console.warn("bumpPickResources error:", e); }
  }

  // ===========================================================
  // ======  SECTION 7 — BLOCK **RIGHT MOUSE BUTTON**  =========
  // ===========================================================
  (function enforceRightMouseOff(){
    const renderEl = viewer?.inputHandler?.domElement || document.getElementById("potree_render_area");
    const canvasEl = viewer?.renderer?.domElement || null;
    const targets = [renderEl || document, canvasEl].filter(Boolean);
    const opts = { capture:false, passive:false };

    function eatRMB(e){
      const isRMB = (e.button === 2) || (e.which === 3);
      if (e.isTrusted && isRMB){
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    function eatAuxRight(e){
      if (e.isTrusted && e.button === 2){
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
    function eatContext(e){
      if (e.isTrusted){
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }

    for (const t of targets){
      t.addEventListener("pointerdown", eatRMB, opts);
      t.addEventListener("pointerup",   eatRMB, opts);
      t.addEventListener("mousedown",   eatRMB, opts);
      t.addEventListener("mouseup",     eatRMB, opts);
      t.addEventListener("click",       eatRMB, opts);
      t.addEventListener("auxclick",    eatAuxRight, opts);
      t.addEventListener("contextmenu", eatContext,  opts);
      try { t.oncontextmenu = () => false; } catch(_) {}
    }
  })();

  // ===========================================================
  // =========  SECTION 8 — LOAD CLOUD & CLIP BOX  =============
  // ===========================================================
  (function loadProjectFromURL(){
    // Prefer /p/<project>; else ?p=<project>; else last non-html path segment
    function getProjectId(){
      const path = location.pathname.replace(/\/+$/,''); // trim trailing slash
      const m = path.match(/\/p\/([^\/?#]+)/);
      if (m) return decodeURIComponent(m[1]);

      const parts = path.split('/');
      const last  = parts[parts.length-1];
      if (last && !/\.html?$/i.test(last)) return decodeURIComponent(last);

      const qp = new URL(location.href).searchParams.get("p");
      return qp || null;
    }

    const project = getProjectId();
    if (!project){
      console.warn("No project specified. Use /p/<project> or ?p=<project>.");
      try { toast("No project specified. Use /p/<project>."); } catch(_) {}
      return;
    }

    const cloudPath = `./pointclouds/${project}/cloud.js`;

    Potree.loadPointCloud(cloudPath, project, function(e){
      const pc = e.pointcloud;
      viewer.scene.addPointCloud(pc);

      const mat = pc.material;
      mat.activeAttributeName = "rgba";
      mat.pointSizeType = Potree.PointSizeType.FIXED;
      mat.shape = Potree.PointShape.CIRCLE;
      mat.size = 1.0;

      viewer.scene.scene.updateMatrixWorld(true);
      pc.updateMatrixWorld(true);

      const bbWorld = pc.boundingBox.clone().applyMatrix4(pc.matrixWorld);
      const size   = new THREE.Vector3();
      const center = new THREE.Vector3();
      bbWorld.getSize(size);
      bbWorld.getCenter(center);
      window.__sceneDiag = Math.max(size.length(), 1); 
      // Clip box
      const margin = 1.03;
      const sx = Math.max(size.x * margin, 0.25);
      const sy = Math.max(size.y * margin, 0.25);
      const sz = Math.max(size.z * margin, 0.25);

      const box = new Potree.BoxVolume();
      box.clip = true;
      box.visible = true;
      if (box.rotation) box.rotation.set(0, 0, 0);
      box.position.copy(center);
      box.scale.set(sx, sy, sz);
      // keep styling minimal to avoid variant conflicts; rely on Potree defaults
      viewer.scene.addVolume(box);
      window.__clipBox = box;

      // Clip settings + ensure visuals enabled
      viewer.setClipMethod(Potree.ClipMethod.INSIDE_ANY);
      viewer.setClipTask(Potree.ClipTask.SHOW_INSIDE);
      try { viewer.setShowClippingBoxes(true); } catch(_){}

      // Fit & stabilize
      viewer.fitToScreen();
      viewer.repaint();
      requestAnimationFrame(()=>requestAnimationFrame(stabilizePicking));
    });
  })();

  // ===========================================================
  // =======  SECTION 9 — GLOBAL MMB (MIDDLE MOUSE) PAN  =======
  // ===========================================================
(() => {
  const v = window.viewer;
  if (!v) return;

  // ---------- Locate key objects ----------
  const canvas =
    v.renderer?.domElement ||
    document.querySelector('#potree_render_area canvas') ||
    document.querySelector('canvas');
  const controls =
    v.sceneControls || v.controls || (v.getControls ? v.getControls(v.scene?.view) : null);
  const cam = v.scene?.camera || v.renderer?.camera;

  if (!canvas || !controls || !cam) return;

  // ---------- Scene scale (for sensible steps) ----------
  const bb = v.scene?.boundingBox || {min:{x:0,y:0,z:0}, max:{x:10,y:10,z:10}};
  const diag = Math.max(1e-6, Math.hypot(
    bb.max.x - bb.min.x,
    bb.max.y - bb.min.y,
    bb.max.z - bb.min.z
  ));

  // ---------- Controls: sane limits & speeds (not aggressive) ----------
  if ('minDistance' in controls) controls.minDistance = diag / 10000;  // let you get close
  if ('maxDistance' in controls) controls.maxDistance = diag * 100;
  if ('zoomSpeed'   in controls) controls.zoomSpeed   = 2.0;
  if ('panSpeed'    in controls) controls.panSpeed    = 1.0;
  if ('rotateSpeed' in controls) controls.rotateSpeed = 0.9;
  if ('enableDamping' in controls) { controls.enableDamping = true; controls.dampingFactor = 0.08; }
  if ('zoomToCursor' in controls) controls.zoomToCursor = true;

  // ---------- Map MMB => PAN (restore middle-mouse panning) ----------
  // Works for OrbitControls-like APIs
  try {
    if (controls.mouseButtons) {
      // Prefer: LEFT rotate, MIDDLE pan, RIGHT dolly (wheel still zooms)
      // THREE.MOUSE constants exist on THREE.MOUSE; if not, use numeric fallback.
      const MOUSE = (window.THREE && THREE.MOUSE) ? THREE.MOUSE : { LEFT:0, MIDDLE:1, RIGHT:2 };
      if ('PAN' in controls.mouseButtons || 'ROTATE' in controls.mouseButtons || 'DOLLY' in controls.mouseButtons) {
        controls.mouseButtons.LEFT   = controls.mouseButtons.ROTATE ?? 'ROTATE';
        controls.mouseButtons.MIDDLE = controls.mouseButtons.PAN    ?? 'PAN';
        controls.mouseButtons.RIGHT  = controls.mouseButtons.DOLLY  ?? 'DOLLY';
      } else {
        // Older API style:
        controls.mouseButtons = { LEFT: MOUSE.LEFT, MIDDLE: MOUSE.MIDDLE, RIGHT: MOUSE.RIGHT };
        // Some builds require explicit states; if so, PAN on MMB is default behavior then.
      }
      controls.update?.();
    }
  } catch(e){ /* harmless if unsupported */ }

  // ---------- Reliable wheel zoom (non-passive) ----------
  // We forward to Potree’s own handler if present; otherwise use a distance-aware fallback.
  const potreeWheel = v.inputHandler && (v.inputHandler.onMouseWheel || v.inputHandler.wheel);
  const forwardWheel = typeof potreeWheel === 'function' ? potreeWheel.bind(v.inputHandler) : null;

  // Do NOT add a capturing stopPropagation layer — let the canvas see events.
  canvas.addEventListener('wheel', (ev) => {
    // Normalize deltas to pixels
    let deltaY = ev.deltaY;
    if (ev.deltaMode === 1) deltaY *= 33;     // lines -> px
    else if (ev.deltaMode === 2) deltaY *= 400; // pages -> px

    if (forwardWheel) {
      // Call Potree’s native wheel so internal states stay consistent
      forwardWheel(ev);
    } else {
      // Fallback zoom: use dolly if available, else move along view direction.
      const factor = deltaY > 0 ? 1.15 : 0.87;
      if (typeof controls.dollyIn === 'function' && typeof controls.dollyOut === 'function') {
        if (factor < 1) controls.dollyIn(1 / factor); else controls.dollyOut(factor);
        controls.update?.();
      } else {
        const dir = new THREE.Vector3();
        cam.getWorldDirection(dir);
        // Step scales with distance to pivot if available; else scale with scene.
        let dist = 0;
        try {
          const view = v.scene?.view;
          const pivot = view?._pivot && view._pivot.isVector3 ? view._pivot : view?.position;
          dist = (pivot && cam.position.distanceTo(pivot)) || 0;
        } catch(_) {}
        const step = (deltaY > 0 ? 1 : -1) * (Math.max(dist, diag/200) / 12);
        cam.position.addScaledVector(dir, step);
        cam.updateProjectionMatrix?.();
        v.repaint?.();
      }
    }
    ev.preventDefault(); // requires passive:false to actually work
  }, { passive: false });

  // ---------- Guard against overlays swallowing input ----------
  // Only disable pointer events for obviously decorative overlays you may have:
  document.querySelectorAll('.viewer-overlay, .hud-overlay').forEach(el => { el.style.pointerEvents = 'none'; });

  // Keep real UI interactive:
  ['#potree_sidebar_container', '.potree_measure_panel'].forEach(sel => {
    const el = document.querySelector(sel);
    if (el) el.style.pointerEvents = 'auto';
  });

  // ---------- “Pan stuck” fix ----------
  const endDrag = () => {
    // OrbitControls-like
    if (controls.state !== undefined) controls.state = 0;
    controls.dragging = false;
    controls.update?.();
    // Potree inputHandler (varies by version)
    if (v.inputHandler) {
      v.inputHandler.drag = false;
      v.inputHandler.dragging = false;
      v.inputHandler.potentialDrag = null;
      v.inputHandler.activeLabel = null;
    }
  };
  ['pointerup','mouseup','mouseleave','blur'].forEach(evt => window.addEventListener(evt, endDrag, true));
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // ---------- Hotkeys: [ (out) and ] (in) ----------
  const zoomByStep = (inward) => {
    const step = 1.2; // mild step
    if (typeof controls.dollyIn === 'function') {
      if (inward) controls.dollyIn(1/step); else controls.dollyOut(step);
      controls.update?.();
    } else {
      const dir = new THREE.Vector3();
      cam.getWorldDirection(dir);
      let dist = 0;
      try {
        const view = v.scene?.view;
        const pivot = view?._pivot && view._pivot.isVector3 ? view._pivot : view?.position;
        dist = (pivot && cam.position.distanceTo(pivot)) || 0;
      } catch(_) {}
      const move = (inward ? -1 : 1) * (Math.max(dist, diag/200) / 8);
      cam.position.addScaledVector(dir, move);
      cam.updateProjectionMatrix?.();
      v.repaint?.();
    }
  };

  window.addEventListener('keydown', (e) => {
    const tag = (e.target && e.target.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || e.metaKey || e.ctrlKey || e.altKey) return;

    // Support both printable keys and physical codes
    if (e.key === '[' || e.code === 'BracketLeft')  { zoomByStep(false); e.preventDefault(); }
    if (e.key === ']' || e.code === 'BracketRight') { zoomByStep(true);  e.preventDefault(); }
  }, { passive: false });

  // ---------- Touch/trackpad gesture sanity ----------
  const style = document.createElement('style');
  style.textContent = `
    #potree_render_area, #potree_render_area canvas, canvas { touch-action: none; overscroll-behavior: contain; }
  `;
  document.head.appendChild(style);
})();

  // ===========================================================
  // ======  SECTION 10 — H TOOL (TOP-ORTHO, Z-CLAMP)  =========
  // ===========================================================
  var LAST_TOOL = null; // 'H','V','M','N','O','P'
  var H_ACTIVE=false, H_MEAS=null, H_IV=null;
  var V_ACTIVE=false, V_MEAS=null, V_IV=null;
  var N_ACTIVE=false, N_MEAS=null, N_STATE=0; // 0=await A, 1=elastic to B
  var N_onMove=null, N_onDown=null, N_onEsc=null;
  var N_restore = {active:false, had:false, val:null};
  var M_MEAS=null;
  var H_restore = {active:false, had:false, val:null};
  var V_restore = {active:false, had:false, val:null};
  var H_restore_input = {active:false, had:false, val:null};

  function setCameraModeSafe(mode, tag){
    viewer.setCameraMode(mode);
    LAST_TOOL = tag || null;
    resyncPickBuffer();
  }

  function startHorizontalMeasure(){
    H_restore.active = true;
    H_restore.had = Object.prototype.hasOwnProperty.call(viewer, 'pickWindowSize');
    H_restore.val = viewer.pickWindowSize;
    viewer.pickWindowSize = 1;

    H_restore_input.active = true;
    H_restore_input.had = !!(viewer.inputHandler && 'pickWindowSize' in viewer.inputHandler);
    H_restore_input.val = viewer.inputHandler ? viewer.inputHandler.pickWindowSize : undefined;
    if (viewer.inputHandler) viewer.inputHandler.pickWindowSize = 1;

    bumpPickResources(true);

    viewer.setCameraMode(Potree.CameraMode.ORTHOGRAPHIC);
    viewer.scene.view.pitch = -Math.PI/2;
    resyncPickBuffer();

    requestAnimationFrame(function(){
      var m = viewer.measuringTool.startInsertion({
        showDistances:true, showAngles:false, showCoordinates:false, showHeight:false, closed:false, name:"Horizontal"
      });
      H_MEAS = m;

      requestAnimationFrame(resyncPickBuffer);

      function onEsc(ev){
        if (ev.key!=="Escape") return;
        ev.stopImmediatePropagation(); ev.preventDefault();
        stopHMode(true);
      }
      document.addEventListener("keydown", onEsc, true);
      function cleanupEsc(){ document.removeEventListener("keydown", onEsc, true); }

      var z0=null;
      function clampZ(){
        if(!m || !m.points || m.points.length===0) return;
        if(z0===null && m.points[0]?.position){ z0=m.points[0].position.z; }
        if(z0!==null){
          for (var i=0;i<m.points.length;i++){
            var p=m.points[i]; if(p&&p.position){ p.position.set(p.position.x,p.position.y,z0); }
          }
          m._update && m._update();
          viewer.requestMeasureUpdate && viewer.requestMeasureUpdate();
          viewer.repaint();
        }
      }

      H_IV = setInterval(function(){
        if(!m || m._disposed) return;
        clampZ();
      }, 50);

      m.addEventListener && m.addEventListener("marker_dropped", clampZ);

      m.addEventListener && m.addEventListener("measurement_finished", function(){
        clampZ(); cleanupEsc();

        if (H_IV){ clearInterval(H_IV); H_IV=null; }
        H_MEAS=null; H_ACTIVE=false;

        bumpPickResources(false);

        if (H_restore.active){
          if (H_restore.had){ viewer.pickWindowSize = H_restore.val; }
          else { try{ delete viewer.pickWindowSize; }catch(e){ viewer.pickWindowSize = undefined; } }
          H_restore.active = false;
        }

        if (H_restore_input.active){
          if (H_restore_input.had && viewer.inputHandler){
            viewer.inputHandler.pickWindowSize = H_restore_input.val;
          } else if (viewer.inputHandler){
            try { delete viewer.inputHandler.pickWindowSize; } catch(e){ viewer.inputHandler.pickWindowSize = undefined; }
          }
          H_restore_input.active = false;
        }

        toast("H mode OFF");
        LAST_TOOL = 'H';
        viewer.repaint();
      });

      H_ACTIVE=true;
      toast("H mode ON: LMB add points • MMB pan • ESC/H to exit");
      LAST_TOOL = 'H';
    });
  }

  function stopHMode(showToast){
    if(!H_ACTIVE){
      bumpPickResources(false);
      if (H_restore.active){
        if (H_restore.had){ viewer.pickWindowSize = H_restore.val; }
        else { try{ delete viewer.pickWindowSize; }catch(e){ viewer.pickWindowSize = undefined; } }
        H_restore.active = false;
      }
      if (H_restore_input.active){
        if (H_restore_input.had && viewer.inputHandler){
          viewer.inputHandler.pickWindowSize = H_restore_input.val;
        } else if (viewer.inputHandler){
          try { delete viewer.inputHandler.pickWindowSize; } catch(e){ viewer.inputHandler.pickWindowSize = undefined; }
        }
        H_restore_input.active = false;
      }
      return;
    }

    H_ACTIVE=false;
    if (H_IV){ clearInterval(H_IV); H_IV=null; }
    try{ viewer.measuringTool?.cancelInsertion?.(); }catch(e){}
    try{ H_MEAS?.cancelInsertion?.(); }catch(e){}
    synthRightClick();
    H_MEAS=null;

    bumpPickResources(false);

    if (H_restore.active){
      if (H_restore.had){ viewer.pickWindowSize = H_restore.val; }
      else { try{ delete viewer.pickWindowSize; }catch(e){ viewer.pickWindowSize = undefined; } }
      H_restore.active = false;
    }
    if (H_restore_input.active){
      if (H_restore_input.had && viewer.inputHandler){
        viewer.inputHandler.pickWindowSize = H_restore_input.val;
      } else if (viewer.inputHandler){
        try { delete viewer.inputHandler.pickWindowSize; } catch(e){ viewer.inputHandler.pickWindowSize = undefined; }
      }
      H_restore_input.active = false;
    }

    if (showToast) toast("H mode OFF");
    viewer.repaint();
    LAST_TOOL = 'H';
  }

  // ===========================================================
  // =========  SECTION 11 — V TOOL (PURE ΔZ CLAMP)  ===========
  // ===========================================================
  function startVerticalMeasure(){
    const comingFromSensitive = (LAST_TOOL === 'M' || LAST_TOOL === 'P' || LAST_TOOL === 'O' || LAST_TOOL === 'N');
    if (comingFromSensitive){
      V_restore.active = true;
      V_restore.had = Object.prototype.hasOwnProperty.call(viewer, 'pickWindowSize');
      V_restore.val = viewer.pickWindowSize;
      if (!(typeof viewer.pickWindowSize === 'number' && viewer.pickWindowSize >= 24)){
        viewer.pickWindowSize = 24;
      }
    } else V_restore.active = false;

    if (comingFromSensitive) resyncPickBuffer();

    requestAnimationFrame(function(){
      var m = viewer.measuringTool.startInsertion({
        showDistances:true, showAngles:false, showCoordinates:false, showHeight:false, closed:false, name:"Vertical"
      });
      V_MEAS = m;

      function onEsc(ev){ if (ev.key!=="Escape") return; ev.stopImmediatePropagation(); ev.preventDefault(); stopVMode(true); }
      document.addEventListener("keydown", onEsc, true);
      function cleanupEsc(){ document.removeEventListener("keydown", onEsc, true); }

      function clampVertical(){
        if (!m || !m.points || m.points.length===0) return;
        for (var i=1;i<m.points.length;i++){
          var prev = m.points[i-1]?.position;
          var cur  = m.points[i]?.position;
          if (prev && cur){ cur.x = prev.x; cur.y = prev.y; } // pure ΔZ
        }
        m._update && m._update(); viewer.requestMeasureUpdate && viewer.requestMeasureUpdate(); viewer.repaint();
      }

      V_IV = setInterval(function(){ if (!m || m._disposed){ if (V_IV){ clearInterval(V_IV); V_IV = null; } return; } clampVertical(); }, 50);
      m.addEventListener && m.addEventListener("marker_dropped", clampVertical);
      m.addEventListener && m.addEventListener("measurement_finished", function(){
        clampVertical(); cleanupEsc();
        if (V_IV){ clearInterval(V_IV); V_IV = null; }
        V_MEAS=null; V_ACTIVE=false;
        if (V_restore.active){
          if (V_restore.had){ viewer.pickWindowSize = V_restore.val; }
          else { try{ delete viewer.pickWindowSize; }catch(e){ viewer.pickWindowSize = undefined; } }
          V_restore.active = false;
        }
        toast("V mode OFF");
        LAST_TOOL='V';
        viewer.repaint();
      });

      V_ACTIVE = true;
      toast("V mode ON: vertical-only chain | LMB add points • MMB pan • ESC/V/H to exit");
      LAST_TOOL = 'V';
    });
  }
  function stopVMode(showToast){
    if (!V_ACTIVE) return;
    V_ACTIVE=false;
    if (V_IV){ clearInterval(V_IV); V_IV = null; }
    try{ viewer.measuringTool?.cancelInsertion?.(); }catch(e){}
    try{ V_MEAS?.cancelInsertion?.(); }catch(e){}
    synthRightClick();
    V_MEAS = null;
    if (V_restore.active){
      if (V_restore.had){ viewer.pickWindowSize = V_restore.val; }
      else { try{ delete viewer.pickWindowSize; }catch(e){ viewer.pickWindowSize = undefined; } }
      V_restore.active = false;
    }
    if (showToast) toast("V mode OFF");
    viewer.repaint();
    LAST_TOOL = 'V';
  }

  // ===========================================================
  // ===  SECTION 12 — N TOOL (3D ELASTIC TWO-CLICK MEASURE) ===
  // ===========================================================
  var N_ACTIVE = false, N_MEAS = null, N_IV = null;
  function start3DQuickMeasure(){
    try { viewer.measuringTool?.cancelInsertion?.(); } catch(_) {}
    if (H_ACTIVE) stopHMode(true);
    if (V_ACTIVE) stopVMode(true);

    requestAnimationFrame(function(){
      var m = viewer.measuringTool.startInsertion({
        showDistances:true, showAngles:false, showCoordinates:false, showHeight:false,
        closed:false, name:"3D"
      });
      N_MEAS = m;
      N_ACTIVE = true;
      LAST_TOOL = 'N';
      document.body.classList.add('n-mode');
      toast("3D measure ON: click A, then click B • N/ESC to exit");

      function countPoints(){
        if (!m) return 0;
        if (Array.isArray(m.points))  return m.points.length;
        if (Array.isArray(m.markers)) return m.markers.length;
        return 0;
      }

      N_IV = setInterval(function(){
        if (!m || m._disposed){
          if (N_IV){ clearInterval(N_IV); N_IV = null; }
          return;
        }
        const cnt = countPoints();
        if (cnt >= 2){
          try {
            if (viewer.measuringTool.finishInsertion) viewer.measuringTool.finishInsertion();
            else viewer.measuringTool.cancelInsertion();
          } catch(_) {}
          cleanup(true);
        }
      }, 40);

      function onEsc(ev){
        if (ev.key !== "Escape") return;
        ev.stopImmediatePropagation(); ev.preventDefault();
        try { viewer.measuringTool.cancelInsertion && viewer.measuringTool.cancelInsertion(); } catch(_) {}
        cleanup(false);
      }
      document.addEventListener("keydown", onEsc, true);

      function cleanup(completed){
        if (N_IV){ clearInterval(N_IV); N_IV = null; }
        try { document.removeEventListener("keydown", onEsc, true); } catch(_) {}

        if (!completed && m){
          try{
            if (viewer.scene?.removeMeasurement) viewer.scene.removeMeasurement(m);
            else {
              const arr = viewer.scene?.measurements || [];
              const i = arr.indexOf(m); if (i>=0) arr.splice(i,1);
            }
          } catch(_) {}
        }

        document.body.classList.remove('n-mode');
        N_ACTIVE = false;
        N_MEAS   = null;
        viewer.repaint && viewer.repaint();
        toast(completed ? "3D segment done" : "3D measure canceled");
        LAST_TOOL = 'N';
      }
    });
  }
  function stop3DQuickMeasure(showToast){
    if (N_IV){ clearInterval(N_IV); N_IV = null; }
    try { viewer.measuringTool?.cancelInsertion?.(); } catch(_) {}
    N_MEAS = null;
    N_ACTIVE = false;
    document.body.classList.remove('n-mode');
    if (showToast) toast("3D measure OFF");
    viewer.repaint && viewer.repaint();
    LAST_TOOL = 'N';
  }

  // ===========================================================
  // =======  SECTION 13 — M TOOL (STANDARD INSERTER)  =========
  // ===========================================================
  function startNormalMeasureFresh(){
    if (H_ACTIVE){ toast("Finish H-mode first (press H)"); return; }
    if (V_ACTIVE){ toast("Finish V-mode first (press V)"); return; }
    if (N_ACTIVE){ stop3DQuickMeasure(true); }

    try { viewer.measuringTool?.cancelInsertion?.(); } catch(e){}
    try { M_MEAS?.cancelInsertion?.(); } catch(e){}
    synthRightClick();

    requestAnimationFrame(function(){
      var m = viewer.measuringTool.startInsertion({
        showDistances:true, showAngles:false, showCoordinates:false, showHeight:false, closed:false, name:"Measure"
      });
      M_MEAS = m; LAST_TOOL = 'M';

      function onEsc(ev){ if (ev.key!=="Escape") return; ev.stopImmediatePropagation(); ev.preventDefault(); stopNormalMeasure(true); }
      document.addEventListener("keydown", onEsc, true);
      function cleanup(){ document.removeEventListener("keydown", onEsc, true); }

      m.addEventListener && m.addEventListener("measurement_finished", function(){ cleanup(); M_MEAS=null; toast("Measure finished"); LAST_TOOL='M'; });
      toast("Measure ON: LMB add points • RMB/dblclick finish • ESC to cancel");
    });
  }
  function stopNormalMeasure(showToast){
    try { viewer.measuringTool?.cancelInsertion?.(); } catch(e){}
    try { M_MEAS?.cancelInsertion?.(); } catch(e){}
    synthRightClick();
    M_MEAS=null;
    if (showToast) toast("Measure OFF");
    viewer.repaint();
    LAST_TOOL = 'M';
  }

  // ===========================================================
  // =======  SECTION 14 — CLEAR ALL MEASUREMENTS  =============
  // ===========================================================
  function clearAllMeasurements(){
    try { viewer.measuringTool?.cancelInsertion?.(); } catch(e){}
    synthRightClick();

    if (H_ACTIVE) stopHMode(false);
    if (V_ACTIVE) stopVMode(false);
    if (N_ACTIVE) stop3DQuickMeasure(false);
    if (M_MEAS){ try{ M_MEAS.cancelInsertion && M_MEAS.cancelInsertion(); }catch(e){} M_MEAS=null; }

    try{
      const arr = viewer.scene?.measurements ? viewer.scene.measurements.slice() : [];
      for (let i=0;i<arr.length;i++){
        try{ viewer.scene.removeMeasurement(arr[i]); }catch(e){}
      }
    }catch(e){}

    viewer.repaint();
    toast("Cleared measurements");
  }

  // ===========================================================
  // ============  SECTION 15 — GLOBAL HOTKEYS  =================
  // ===========================================================
  (function(){
    function isTypingInField(t){
      return t && (t.isContentEditable || /^(input|textarea|select)$/i.test(t.nodeName));
    }

    function handleHotkey(k){
      if (k === "h"){ if (V_ACTIVE){ stopVMode(true); return; } if (N_ACTIVE){ stop3DQuickMeasure(true); return; } if (!H_ACTIVE) startHorizontalMeasure(); else stopHMode(true); }
      if (k === "v"){ if (H_ACTIVE){ stopHMode(true); return; } if (N_ACTIVE){ stop3DQuickMeasure(true); return; } if (!V_ACTIVE) startVerticalMeasure(); else stopVMode(true); }
      if (k === "m"){ if (N_ACTIVE){ stop3DQuickMeasure(true); } startNormalMeasureFresh(); }
      if (k === "n"){ if (!N_ACTIVE) start3DQuickMeasure(); else stop3DQuickMeasure(true); }
      if (k === "o"){ setCameraModeSafe(Potree.CameraMode.ORTHOGRAPHIC, 'O'); viewer.repaint(); toast("Orthographic"); }
      if (k === "p"){ setCameraModeSafe(Potree.CameraMode.PERSPECTIVE,  'P'); viewer.repaint(); toast("Perspective"); }
      if (k === "b"){
        var box = window.__clipBox; if (!box || !viewer || !viewer.setClipTask) return;
        if (box.visible){ box.visible=false; viewer.setClipTask(Potree.ClipTask.NONE); toast("Clip box: hidden"); }
        else { box.visible=true; viewer.setClipTask(Potree.ClipTask.SHOW_INSIDE); toast("Clip box: shown"); }
        viewer.repaint();
      }
      if (k === "c"){ clearAllMeasurements(); }
    }

    document.addEventListener("keydown", function(ev){
      const k = (ev.key || '').toLowerCase();
      if (!/[hvmnopbc]/.test(k)) return;
      if (ev.repeat || isTypingInField(ev.target)) return;
      ev.preventDefault();
      ev.stopPropagation();

      if (document.activeElement && document.activeElement !== document.body){
        try { document.activeElement.blur(); } catch(_) {}
      }

      handleHotkey(k);
      if (k === "n" && !N_ACTIVE){
        setTimeout(()=>{ if (!N_ACTIVE) handleHotkey('n'); }, 0);
      }
    }, {capture:true});
  })();

  </script>

  <!-- =========================================================
======  SECTION 16 — CONSTANT-STEP WHEEL ZOOM (CURSOR)  ======
========================================================= -->
<script>
(function FinalControlTuning(){
  if (!window.viewer) { window.addEventListener('load', FinalControlTuning, {once:true}); return; }

  function tune(){
    const v = viewer;
    const controls = v.getControls(v.scene.view);
    if (!controls) return;

    // Faster, snappier wheel zoom (native Potree handler stays in charge)
    controls.zoomSpeed = 4.0;       // 2–6 is a good range
    controls.enableDamping = false;

    // Always zoom to cursor if supported (across Potree variants)
    try { controls.zoomToMouse  = true; } catch(_){}
    try { controls.zoomToCursor = true; } catch(_){}
    try {
      if (controls.controls) {
        controls.controls.zoomToMouse  = true;
        controls.controls.zoomToCursor = true;
      }
    } catch(_){}

    // Don’t stall when close
    if (v.scene.view && typeof v.scene.view.minRadius === 'number') {
      v.scene.view.minRadius = 0.001;
    }

    v.repaint && v.repaint();
  }

  tune();
  // Re-assert after scene changes so nothing overrides it
  viewer.addEventListener?.('pointcloud_added', tune);
  viewer.addEventListener?.('scene_changed',    tune);
})();
</script>

</body>
</html>
